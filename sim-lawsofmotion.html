<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Laws of Motion Lab (Class 11)</title>
    <meta name="description" content="Interactive F=ma simulation with velocity and displacement graphs." />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="app.css" />
    <script src="theme.js"></script>
    <style>
      .two { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      @media (max-width: 900px){ .two { grid-template-columns: 1fr; } }
      .control { margin: 8px 0; }
      label { display:block; font-weight:600; margin-bottom:6px; }
      input[type=range], input[type=number]{ width: 100%; }
    </style>
  </head>
  <body>
    <nav class="topnav">
      <div class="brand">Student Physics Lab</div>
      <div class="links">
        <a href="index.html">Simulator</a>
        <a href="mysims.html">My Simulations</a>
        <a href="class11.html">Class 11 Topics</a>
        <a href="class12.html">Class 12 Topics</a>
        <a href="dashboard.html">Profile</a>
      </div>
      <div class="right">
        <button class="btn" id="themeToggle" type="button">Toggle Theme</button>
        <a class="btn" href="class11.html">Back</a>
      </div>
    </nav>

    <div class="container">
      <div class="card">
        <h2>Laws of Motion: F = m·a</h2>
        <p class="text-muted">Adjust force F and mass m. See acceleration, velocity and displacement over time. Assumes constant F, no friction, v(0)=v₀, s(0)=s₀.</p>
        <div class="two">
          <div>
            <div class="control">
              <label for="F">Force F (N)</label>
              <input id="F" type="range" min="0" max="100" step="1" value="20" />
              <div class="text-muted" id="FOut"></div>
            </div>
            <div class="control">
              <label for="m">Mass m (kg)</label>
              <input id="m" type="range" min="0.5" max="20" step="0.5" value="5" />
              <div class="text-muted" id="mOut"></div>
            </div>
            <div class="control">
              <label for="v0">Initial velocity v₀ (m/s)</label>
              <input id="v0" type="range" min="0" max="20" step="0.5" value="0" />
              <div class="text-muted" id="v0Out"></div>
            </div>
            <div class="control">
              <label for="tMax">Duration t_max (s)</label>
              <input id="tMax" type="range" min="1" max="20" step="1" value="10" />
              <div class="text-muted" id="tOut"></div>
            </div>
            <div class="hstack">
              <button class="btn primary" id="run">Run Simulation</button>
              <button class="btn" id="reset">Reset</button>
              <button class="btn" id="save">Save</button>
              <span id="note" class="text-muted"></span>
            </div>
            <div class="hstack"><strong>a =</strong> <span id="aOut" class="text-muted">—</span> m/s²</div>
          </div>
          <div class="vstack">
            <div class="card">
              <div class="hstack" style="justify-content: space-between;">
                <div>Real-time Motion (Distance in meters)</div>
                <div id="simNow" class="text-muted">—</div>
              </div>
              <canvas id="simCanvas" style="width:100%;height:220px"></canvas>
            </div>
            <div class="card">
              <div class="hstack" style="justify-content: space-between;">
                <div>Velocity v(t)</div>
                <div id="vNow" class="text-muted">—</div>
              </div>
              <canvas id="chartV" style="width:100%;height:200px"></canvas>
            </div>
            <div class="card">
              <div class="hstack" style="justify-content: space-between;">
                <div>Displacement s(t)</div>
                <div id="sNow" class="text-muted">—</div>
              </div>
              <canvas id="chartS" style="width:100%;height:200px"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('themeToggle');
        if (btn && window.Theme) btn.addEventListener('click', () => Theme.toggle());
      });
    </script>
    <script type="module">
      import { ensureAuthAndDb, saveSimulation, makeChart, snapshotCanvas } from './sim-lib.js';
      const fmt = (n, d=2) => Number(n).toFixed(d);

      const FEl = document.getElementById('F');
      const mEl = document.getElementById('m');
      const v0El = document.getElementById('v0');
      const tMaxEl = document.getElementById('tMax');
      const FOut = document.getElementById('FOut');
      const mOut = document.getElementById('mOut');
      const v0Out = document.getElementById('v0Out');
      const tOut = document.getElementById('tOut');
      const aOut = document.getElementById('aOut');
      const vNow = document.getElementById('vNow');
      const sNow = document.getElementById('sNow');
      const note = document.getElementById('note');
      const runBtn = document.getElementById('run');
      const resetBtn = document.getElementById('reset');
      const saveBtn = document.getElementById('save');
      const simCanvas = document.getElementById('simCanvas');
      const simNow = document.getElementById('simNow');

      function updateLabels(){
        FOut.textContent = `F = ${fmt(FEl.value,1)} N`;
        mOut.textContent = `m = ${fmt(mEl.value,1)} kg`;
        v0Out.textContent = `v₀ = ${fmt(v0El.value,1)} m/s`;
        tOut.textContent = `t_max = ${fmt(tMaxEl.value,0)} s`;
        aOut.textContent = `${fmt(Number(FEl.value)/Number(mEl.value),2)}`;
      }

      function computeSeries(){
        const F = Number(FEl.value), m = Number(mEl.value), v0 = Number(v0El.value), tMax = Number(tMaxEl.value);
        const a = F/m; const steps = 150; const dv = [], ds = [];
        let vmax=0, smax=0, smin=0;
        for (let i=0;i<=steps;i++){
          const t = (i/steps)*tMax;
          const v = v0 + a*t;
          const s = v0*t + 0.5*a*t*t;
          if (v>vmax) vmax=v; if (s>smax) smax=s; if (s<smin) smin=s;
          dv.push({x:t, y:v}); ds.push({x:t, y:s});
        }
        return { dv, ds, tMax, vmax, smax, smin, a, v0 };
      }

      function render(){
        const { dv, ds, tMax, vmax, smax, smin } = computeSeries();
        // Charts
        const cv = document.getElementById('chartV');
        const cs = document.getElementById('chartS');
        const chV = makeChart(cv, { xLabel:'Time', yLabel:'Velocity', xUnit:'s', yUnit:'m/s', xMax: Math.max(1,tMax), yMax: Math.max(1, Math.abs(vmax)*1.1) });
        const chS = makeChart(cs, { xLabel:'Time', yLabel:'Displacement', xUnit:'s', yUnit:'m', xMax: Math.max(1,tMax), yMax: Math.max(1, Math.max(Math.abs(smax), Math.abs(smin))*1.1) });
        chV.plotSeries([{ points: dv, color:'#6aa6ff', markers:true, annotate:(pt,i,p,ctx)=>{ if(i%20===0){ ctx.fillStyle='white'; ctx.fillText(`${fmt(pt.x)} s, ${fmt(pt.y)} m/s`, p.x+4, p.y-6);} } }]);
        chS.plotSeries([{ points: ds, color:'#e9a23b', markers:true, annotate:(pt,i,p,ctx)=>{ if(i%20===0){ ctx.fillStyle='white'; ctx.fillText(`${fmt(pt.x)} s, ${fmt(pt.y)} m`, p.x+4, p.y-6);} } }]);
        vNow.textContent = `${fmt(dv[dv.length-1].y)} m/s @ t=${fmt(dv[dv.length-1].x)} s`;
        sNow.textContent = `${fmt(ds[ds.length-1].y)} m @ t=${fmt(ds[ds.length-1].x)} s`;
        // Static axis draw for sim canvas
        drawSimAxis();
        drawSimAtTime(0);
      }

      FEl.addEventListener('input', ()=>{ updateLabels(); render(); });
      mEl.addEventListener('input', ()=>{ updateLabels(); render(); });
      v0El.addEventListener('input', ()=>{ updateLabels(); render(); });
      tMaxEl.addEventListener('input', ()=>{ updateLabels(); render(); });

      let animId = null;
      runBtn.addEventListener('click', ()=>{
        cancelAnimationFrame(animId);
        const { dv, ds, tMax } = computeSeries();
        const cv = document.getElementById('chartV');
        const cs = document.getElementById('chartS');
        const vmax = Math.max(...dv.map(p=>Math.abs(p.y))); const sAbsMax = Math.max(...ds.map(p=>Math.abs(p.y)));
        const chV = makeChart(cv, { xLabel:'Time', yLabel:'Velocity', xUnit:'s', yUnit:'m/s', xMax: Math.max(1,tMax), yMax: Math.max(1, vmax*1.1) });
        const chS = makeChart(cs, { xLabel:'Time', yLabel:'Displacement', xUnit:'s', yUnit:'m', xMax: Math.max(1,tMax), yMax: Math.max(1, sAbsMax*1.1) });
        const start = performance.now();
        function frame(now){
          const elapsed = (now - start)/1000; // seconds real-time
          const t = Math.min(tMax, elapsed); // sync sim time to real seconds; t_max seconds total
          const idx = Math.floor((t/tMax) * (dv.length-1));
          chV.plotSeries([{ points: dv.slice(0, idx+1), color:'#6aa6ff' }]);
          chS.plotSeries([{ points: ds.slice(0, idx+1), color:'#e9a23b' }]);
          drawSimAxis();
          drawSimAtTime(t);
          if (t < tMax) { animId = requestAnimationFrame(frame); }
        }
        animId = requestAnimationFrame(frame);
      });

      resetBtn.addEventListener('click', ()=>{ note.textContent=''; cancelAnimationFrame(animId); updateLabels(); render(); });

      saveBtn.addEventListener('click', async ()=>{
        note.textContent = 'Saving...';
        const { auth, db, user } = await ensureAuthAndDb();
        const params = { F: Number(FEl.value), m: Number(mEl.value), v0: Number(v0El.value), tMax: Number(tMaxEl.value) };
        const snapshot = snapshotCanvas(document.getElementById('chartV'));
        const { dv, ds } = computeSeries();
        try {
          await saveSimulation(db, user, {
            title: 'Laws of Motion: F=ma', topic: 'Laws of Motion', params,
            results: { vEnd: dv[dv.length-1], sEnd: ds[ds.length-1] }, snapshot,
            resumeUrl: window.location.pathname + window.location.search
          });
          note.textContent = 'Saved!';
        } catch (e) { console.error(e); note.textContent = 'Save failed.'; }
      });

      // --- Real-time animation helpers ---
      function getSimScale(){
        const { ds } = computeSeries();
        const sVals = ds.map(p=>p.y);
        const sMin = Math.min(0, ...sVals);
        const sMax = Math.max(0, ...sVals);
        return { sMin, sMax };
      }

      function drawSimAxis(){
        if (!simCanvas) return;
        const ctx = simCanvas.getContext('2d');
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = simCanvas.getBoundingClientRect();
        const cw = Math.max(320, Math.floor(rect.width));
        const ch = Math.max(160, Math.floor(rect.height));
        simCanvas.width = Math.floor(cw * dpr);
        simCanvas.height = Math.floor(ch * dpr);
        ctx.clearRect(0,0,simCanvas.width, simCanvas.height);
        ctx.fillStyle = '#0b1020'; ctx.fillRect(0,0,simCanvas.width, simCanvas.height);
        const margins = { left: 50*dpr, right: 20*dpr, top: 20*dpr, bottom: 40*dpr };
        const w = simCanvas.width - margins.left - margins.right;
        const y = simCanvas.height - margins.bottom;
        // Axis line
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 2*dpr;
        ctx.beginPath(); ctx.moveTo(margins.left, y); ctx.lineTo(margins.left + w, y); ctx.stroke();
        // Ticks in meters
        const { sMin, sMax } = getSimScale();
        const range = Math.max(1e-3, sMax - sMin);
        const meters = chooseTick(range);
        ctx.fillStyle = 'rgba(230,233,240,0.9)'; ctx.font = `${12*dpr}px Inter, sans-serif`;
        for (let m = Math.ceil(sMin/meters)*meters; m<=sMax; m+=meters){
          const tx = margins.left + ((m - sMin)/range)*w;
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath(); ctx.moveTo(tx, y-6*dpr); ctx.lineTo(tx, y+6*dpr); ctx.stroke();
          ctx.fillText(`${m.toFixed(0)} m`, tx-12*dpr, y+20*dpr);
        }
        // Axis label
        ctx.fillText('Distance (m)', margins.left, y+34*dpr);
      }

      function chooseTick(range){
        // nice tick step for meters
        const steps = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100];
        for (const s of steps){ if (range/ s <= 10) return s; }
        return 100;
      }

      function drawSimAtTime(t){
        if (!simCanvas) return;
        const ctx = simCanvas.getContext('2d');
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const margins = { left: 50*dpr, right: 20*dpr, top: 20*dpr, bottom: 40*dpr };
        const w = simCanvas.width - margins.left - margins.right;
        const baseY = simCanvas.height - margins.bottom;
        const { dv, ds, tMax, a, v0 } = computeSeries();
        const { sMin, sMax } = getSimScale();
        const range = Math.max(1e-3, sMax - sMin);
        // compute kinematics at time t
        const v = v0 + a*t;
        const s = v0*t + 0.5*a*t*t;
        const x = margins.left + ((s - sMin)/range) * w;
        const r = 8*dpr;
        // Ball glow
        const g = ctx.createRadialGradient(x-r/2, baseY-r/2, r/4, x, baseY, r*2);
        g.addColorStop(0, 'rgba(106,166,255,0.5)'); g.addColorStop(1, 'rgba(106,166,255,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, baseY, r*1.8, 0, Math.PI*2); ctx.fill();
        // Ball
        const ballGrad = ctx.createLinearGradient(x, baseY-r, x, baseY+r);
        ballGrad.addColorStop(0, '#d1e2ff'); ballGrad.addColorStop(1, '#89b5ff');
        ctx.fillStyle = ballGrad; ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1*dpr;
        ctx.beginPath(); ctx.arc(x, baseY, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        // Labels near object
        ctx.fillStyle = 'rgba(230,233,240,0.95)'; ctx.font = `${13*dpr}px Inter, sans-serif`;
        ctx.fillText(`s=${fmt(s)} m`, x+12*dpr, baseY-22*dpr);
        ctx.fillText(`v=${fmt(v)} m/s`, x+12*dpr, baseY-8*dpr);
        ctx.fillText(`a=${fmt(a)} m/s²`, x+12*dpr, baseY+6*dpr);
        if (simNow) simNow.textContent = `t=${fmt(t)} s`;
      }

      updateLabels(); render();
    </script>
  </body>
</html>

